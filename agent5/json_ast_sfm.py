"""
Build SFM (Scenario Flow Model) from JSON AST generated by libclang.

This module reads the JSON AST file and converts it to SFM for flowchart generation.
"""
from __future__ import annotations

import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from agent5.scenario_extractor import DetailLevel, SFMBuilder, SFMEdge, SFMNode, ScenarioFlowModel


@dataclass
class ASTNode:
    """Represents a node from the JSON AST."""
    
    uid: str
    name: str
    line_start: int
    column_start: int
    line_end: int
    column_end: int
    file_name: str
    module_name: str
    description: str
    flowchart: str
    callees: list[dict[str, str]]
    callers: list[dict[str, str]]


def load_ast_json(json_path: str | Path) -> list[ASTNode]:
    """Load AST nodes from JSON file."""
    json_path = Path(json_path)
    
    if not json_path.exists():
        raise FileNotFoundError(f"AST JSON file not found: {json_path}")
    
    with open(json_path, encoding="utf-8") as f:
        data = json.load(f)
    
    nodes = []
    for item in data:
        node = ASTNode(
            uid=item["uid"],
            name=item["name"],
            line_start=item["line_start"],
            column_start=item["column_start"],
            line_end=item["line_end"],
            column_end=item["column_end"],
            file_name=item["file_name"],
            module_name=item["module_name"],
            description=item.get("description", ""),
            flowchart=item.get("flowchart", ""),
            callees=item.get("callees", []),
            callers=item.get("callers", []),
        )
        nodes.append(node)
    
    return nodes


def build_sfm_from_ast(
    ast_nodes: list[ASTNode],
    entry_function_uid: str | None = None,
    *,
    max_steps: int = 30,
    detail_level: DetailLevel = DetailLevel.MEDIUM,
) -> ScenarioFlowModel:
    """
    Build SFM from AST nodes.
    
    Args:
        ast_nodes: List of AST nodes from JSON
        entry_function_uid: UID of the entry function (if None, use first node)
        max_steps: Maximum steps in the scenario
        detail_level: Level of detail (HIGH, MEDIUM, DEEP)
        
    Returns:
        ScenarioFlowModel
    """
    if not ast_nodes:
        raise RuntimeError("No AST nodes provided")
    
    # Build node lookup
    node_map: dict[str, ASTNode] = {node.uid: node for node in ast_nodes}
    
    # Determine entry function
    if entry_function_uid is None:
        # Use first node as entry point
        entry_function_uid = ast_nodes[0].uid
    elif entry_function_uid not in node_map:
        raise RuntimeError(f"Entry function UID not found: {entry_function_uid}")
    
    entry_node = node_map[entry_function_uid]
    
    # Build SFM
    builder = SFMBuilder(max_steps=max_steps, detail_level=detail_level)
    
    # Add start node
    start_id = "start"
    
    # Add entry function as first process
    entry_label = entry_node.name or "Entry Function"
    entry_id = builder.add_process(entry_label)
    if not entry_id:
        raise RuntimeError("Failed to add entry function to SFM")
    
    builder.add_edge(start_id, entry_id)
    
    # Process call graph starting from entry function
    visited: set[str] = {entry_function_uid}
    frontier: list[str] = [entry_id]
    
    exit_points = _process_call_graph(
        entry_node,
        node_map,
        builder,
        frontier,
        visited,
        detail_level,
        max_steps,
    )
    
    # Connect remaining exit points to end
    for node_id in exit_points:
        if node_id and node_id != "end":
            builder.add_edge(node_id, "end")
    
    return builder.build()


def _process_call_graph(
    current_node: ASTNode,
    node_map: dict[str, ASTNode],
    builder: SFMBuilder,
    frontier: list[str],
    visited: set[str],
    detail_level: DetailLevel,
    max_steps: int,
) -> list[str]:
    """
    Process call graph recursively to build SFM.
    
    Returns:
        New frontier (list of node IDs that represent exit points)
    """
    if builder._step_count >= max_steps:
        return frontier
    
    if not frontier:
        return frontier
    
    # Collect all exit points from processed callees
    exit_points: list[str] = []
    
    # Process callees based on detail level
    for callee_ref in current_node.callees:
        if builder._step_count >= max_steps:
            break
            
        callee_uid = callee_ref.get("uid")
        if not callee_uid or callee_uid not in node_map:
            continue
        
        # Check if we should include this callee based on detail level
        callee_node = node_map[callee_uid]
        if not _should_include_callee(callee_node, detail_level):
            continue
        
        # Avoid cycles
        if callee_uid in visited:
            # Create a reference node instead of recursing
            ref_id = builder.add_process(f"Call {callee_node.name}")
            if ref_id:
                for src in frontier:
                    if src != "end":
                        builder.add_edge(src, ref_id)
                exit_points.append(ref_id)
            continue
        
        visited.add(callee_uid)
        
        # Add callee as process node
        callee_label = callee_node.name or "Function"
        callee_id = builder.add_process(callee_label)
        if not callee_id:
            break
        
        # Connect from current frontier to callee
        for src in frontier:
            if src != "end":
                builder.add_edge(src, callee_id)
        
        # Recursively process callee's call graph
        callee_exit_points = _process_call_graph(
            callee_node,
            node_map,
            builder,
            [callee_id],
            visited,
            detail_level,
            max_steps,
        )
        
        # Collect exit points from this callee
        exit_points.extend(callee_exit_points)
    
    # Return merged exit points, or original frontier if no callees were processed
    return exit_points if exit_points else frontier


def _should_include_callee(node: ASTNode, detail_level: DetailLevel) -> bool:
    """
    Determine if a callee should be included based on detail level.
    
    This mirrors the logic from scenario_extractor._classify_call.
    """
    name_lower = node.name.lower()
    
    # Always exclude noise
    noise_keywords = (
        "log", "spdlog", "printf", "fprintf", "sprintf", "cout", "cerr",
        "trace", "metric", "stats", "telemetry", "debug", "info", "warn",
        "warning", "error", "assert", "check", "verify",
    )
    if any(kw in name_lower for kw in noise_keywords):
        return False
    
    # HIGH level: ONLY major business operations
    if detail_level == DetailLevel.HIGH:
        major_keywords = ("create", "execute", "handle", "process", "delete", "init", "destroy")
        return any(kw in name_lower for kw in major_keywords)
    
    # MEDIUM level: Business + validations + state (but NOT critical)
    elif detail_level == DetailLevel.MEDIUM:
        medium_keywords = (
            "create", "execute", "handle", "process", "delete", "init", "destroy",
            "make", "build", "run", "send", "receive", "perform",
            "parse", "check", "validate", "isvalid", "verify",
            "set", "update", "add", "insert", "remove", "erase",
            "open", "close", "start", "stop", "save", "write",
        )
        return any(kw in name_lower for kw in medium_keywords)
    
    # DEEP level: Include everything except utility
    elif detail_level == DetailLevel.DEEP:
        return True
    
    return False


def find_function_by_name(ast_nodes: list[ASTNode], function_name: str) -> ASTNode | None:
    """Find an AST node by function name."""
    for node in ast_nodes:
        if node.name == function_name:
            return node
        # Try case-insensitive match
        if node.name.lower() == function_name.lower():
            return node
        # Try partial match
        if function_name.lower() in node.name.lower():
            return node
    return None


def build_sfm_from_json_file(
    json_path: str | Path,
    function_name: str | None = None,
    *,
    max_steps: int = 30,
    detail_level: DetailLevel = DetailLevel.MEDIUM,
) -> ScenarioFlowModel:
    """
    Build SFM from JSON AST file.
    
    Args:
        json_path: Path to JSON AST file
        function_name: Name of entry function (if None, use first node)
        max_steps: Maximum steps in scenario
        detail_level: Level of detail
        
    Returns:
        ScenarioFlowModel
    """
    ast_nodes = load_ast_json(json_path)
    
    entry_uid = None
    if function_name:
        entry_node = find_function_by_name(ast_nodes, function_name)
        if entry_node:
            entry_uid = entry_node.uid
        else:
            raise RuntimeError(f"Function '{function_name}' not found in AST")
    
    return build_sfm_from_ast(
        ast_nodes,
        entry_uid,
        max_steps=max_steps,
        detail_level=detail_level,
    )


